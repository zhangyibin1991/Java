<h2>概述</h2>
代理是☝️种设计模式，为某个对象提供☝️个代理，以控制对该对象的访问。代理模式在 Spring、Dubbo 这些框架、组件中被广泛地使用来实现自己的特性，例如 Spring AOP。代理可以分为两种类型：
<ul>
  <li>静态代理：在编译阶段已经确定代理关系，简而言之委托类、代理类是直接硬编码，代理类直接存在编译生成的二进制文件中。</li>
  <li>动态代理：代理类的字节码文件是在运行过程中动态生成。</li>
</ul>
<h2>静态代理</h2>
<p>
下面是静态代理的一个例子。类 <code>Entruster</code> 作为委托者，我们需要将它的方法进行代理。我们可以定义一个代理类 <code>Proxy</code> ，并继承委托类（如2所示），重写委托类中的方法（如5所示）。为了能够将方法代理到委托对象上，代理对象需要持有一个委托类的实例（如3中所示），我们可以通过代理类的构造方法引入委托对象（如4所示）。当然，取而代之的，也可以通过提供 <code>Setter</code> 来设置。这样之后，代理对象只要在重写的方法中通过调用对应的委托对象的方法来实现代理（如5、6所示）。
</p>
<p>
我们可以在调用代理对象方法之前、之后加上额外的代码。例如可以在调用前后记录时间来监测接口所花费的时间、在调用前后加入日志处理来跟踪接口调用情况、在调用之前加入权限控制的代码、调用之后对返回结果信息进行脱敏处理等等。
</p>
<pre>
<code>
// 1.
// * 委托类
// 是方法的实际执行者
public class Entruster {
    @Override
    public void method() {
        // do something...
    }
}
// 2.
// * 代理类
// 将方法的调用代理到委托类上
public class Proxy extends Entruster{
    // 3.
    // * 委托对象
    // 真正做事的对象，可以称之为 realSubject。
    private Entrust entruster;
    // 4.
    public Proxy(Entruster entruster) {
        this.entruster = entruster;
    }
    // 5.
    // 代理类实现委托类夫接口的方法，这样代理类就拥有了和委托类相同的方法
    @Override
    public void method() {
        // do something before calling real-subject's method
        // ...
        // 6.
        // 执行委托对象的方法，完成代理
        entruster.method();
        // do something after calling real-subject's method
        // ...
    }
}
</code>
</pre>
