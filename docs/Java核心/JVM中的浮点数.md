摘自《Java虚拟机规范(Java SE8版)》 2.3.2浮点类型、取值集合及浮点值<p/>
	<p>浮点类型包含<code>float</code>类型和<code>double</code>类型两种，他们在概念上与《IEEE Standard for Binary Floating-Point Arithmetic》(ANSI/IEEE Std.754-1985, New York)标准中定义的32位单精度和64位双精度IEEE-754格式的取值与操作是一致的。</p>
	<p><u>IEEE 754 标准的内容不仅包括了正负的带符号量（sign-magnitude number），而且包括了正负零、正负无穷大的一个特殊的“非数字”标识（Not-a-Number，下午用NaN表示）。</u>NaN值用于表示某些无效的运算操作，例如除以0等情况。</p>
	<p>所有Java虚拟机的实现都必须支持两种标准的浮点数集合：<strong>单精度浮点数集合</strong>和<strong>双精度浮点数集合</strong>。另外，Java虚拟机实现可以自由选择是否支持<strong>单精度浮点数扩展指数集合</strong>和<strong>双精度浮点数扩展指数集合</strong>中的一种或者全部。这些扩展指数集合可能在某些特定情况下代替标准浮点数集合来表示<code>fload</code>和<code>double</code>类型的数值。</p>
	<p>任意一个非零的、可数的任意浮点值都可以表示为 s x m x 2<sup><small>(e-N+1)</small></sup>的形式，其中s可以+1或者-1，m可以是一个小于2<sup><small>N</small></sup>的正整数，e是一个介于E<sub><small>min</small></sub>&ge;-(2<sup><small>K-1</small></sup>-2)和E<sub><small>max</small></sub>=2<sup><small>K-1</small></sup>-1之间的整数（包括E<sub><small>min</small></sub>和<sub><small>max</small></sub>）。这里的 N 和 K 两个参数的取值范围决定于当前采用的浮点数值集合。部分浮点数使用这种规则得到的表现形式可能不是唯一的，例如，在指定的数值集合内，可以存在一个数字 v，它能找到特定的s 、m 和 e 值来表示，使得其中 m 是偶数，并且 e 小于 2<sup><small>K-1</small></sup>，这样我们就能够通过把 m 的值减半再将 e 的值增加1的方式来得到 v 的另外一种不同的表示形式。在这些表示形式中，如果其中某种表现形式中 m 的值满足条件 m &ge; 2<sup><small>N-1</small></sup>，那就称这种表示为<b>标准表示</b>（normalized representation），你满足这个条件的其他表现形式就称为非标准表示（denormalized representation）。如果某个数值不存在任何满足 m &ge; 2<sup><small>N-1</small></sup>的表现形式，即不存在任何标准表示，那就称这个数字为非标准值（denormalized value）。</p>
<table>
	<tr>
		<th>参数</th>
		<th>单精度浮点数集合</th>
		<th>单精度扩展指数集合</th>
		<th>双精度浮点数集合</th>
		<th>双精度扩展指数集合</th>
	</tr>
	<tr>
		<td>N</td>
		<td>24</td>
		<td>24</td>
		<td>53</td>
		<td>53</td>
	</tr>
	<tr>
		<td>K</td>
		<td>8</td>
		<td>&ge;11</td>
		<td>11</td>
		<td>&ge;15</td>
	</tr>
	<tr>
		<td>E<sub><small>max</small></sub></td>
		<td>+127</td>
		<td>&ge;+1023</td>
		<td>+1023</td>
		<td>&ge;+16383</td>
	</tr>
	<tr>
		<td>E<sub><small>min</small></sub></td>
		<td>-126</td>
		<td>&le;-1022</td>
		<td>-1022</td>
		<td>&le;-16382</td>
	</tr>
</table>
<p>
如果虚拟机实现支持了（无论是支持一种还是支持全部）扩展指数集合，那每一种支持的扩展指数集合都有一个由具体虚拟机实现决定的参数 K，上表中给出了这个参数的约束范围（&ge;11 或 &ge;15），这个参数也决定了 E<sub><small>max</small></sub> 和 E<sub><small>min</small></sub> 两个衍生参数的取值范围。
</p>
<p>
上述四种数值集合不仅包含可数的非零值，而且包括5个特殊的数值：正数零、负数零、正无穷大、负无穷大和 NaN。
</p>
<p>
有一点需要注意的是，表中的约束经过精心设计，可以保证每一个单精度浮点数集合中的元素都一定是单精度扩展指数集合、双精度浮点数集合和双精度扩展指数集合中的元素。与此类似，每一个双精度浮点数集合中的元素都是双精度扩展指数集合的元素。换句话说，<u>每一种扩展指数集合都比相应的标准浮点数集合更大的指数取值范围，但是不会由更高的精度</u>。
</p>
<p>
每一个单精度浮点数集合中的元素都可以精确地使用 IEEE 754 标准中定义的单精度浮点格式表示出来，但 NaN 例外，取值集合中只有一个值用来表示 NaN。（而 IEEE 754 却规定了 2<sup>24</sup>-2 种不同的值，都可用来表示 NaN）。与此类似，每一个双精度浮点数集合种的元素都可以精确的使用 IEEE 754 标准中定义的双精度浮点格式表示出来，但 NaN 例外，取值集合中也只有1个值来表示 NaN。（而 IEEE 754 却规定了2<sup><small>53</small></sup> - 2种不同的值，都可以用来表示 NaN）。不过请注意，在这里定义的单精度扩展指数集合和双精度扩展指数集合中的元素和 IEEE 754 标准里的单精度扩展与双精度扩展格式的表示并<b>不完全一致</b>。除了class文件格式中明确限定浮点值表示方式的场合之外，本规范（*指的是JVM规范）并不强求采用何种形式来表示浮点数。
</p>
<p>
	上面提到的单精度浮点数集合、单精度扩展指数集合、双精度浮点数集合、双精度扩展指数集合都并不是具体的数据类型。虚拟机实现可以通过单精度浮点数集合的元素来表示一个<code>float</code>类型的数值，但是在某些特定的环境中，可以使用单精度扩展指数集合元素来代替。相类似的，虚拟机实现可以通过双精度浮点数集合来表示一个<code>double</code>类型的数值，但是在某些特定的环境中，可以使用双精度扩展指数集合元素来代替。
</p>
<p>
除了 NaN 以外，浮点数集合中的所有元素都是<b>有序</b>的。如果把它们从小到大按顺序排列好，那顺序将会是：负无穷、可数负数、正负0、可数正数、正无穷。
</p>
<p>
在浮点数中，<u>正数零和负数零是相等的</u>，但是他们在操作上会有区别。例如，1.0 除以 0.0 会产生正无穷大的结果，而 1.0 除以 -0.0 则会产生负无穷大的结果。
</p>
<p>
NaN 是无序的，只要有操作数是 NaN，那么对他进行任何数值比较和等值测试都会返回<code>false</code>。值得一提的是，<u>有且只有 NaN 这一个数在与自身比较是否相等时会得到<code>false</code>。任何数值与 NaN 进行不等值比较都会返回<code>true</code></u>。
</p>
